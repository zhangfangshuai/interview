<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>deep_clone</title>
</head>
<body>
    <h3>deep_clone</h3>
    <div style="width: 100%; height: 2px; background: #F5F5F5;"></div>
    <div>
        <h3>JS的数据类型</h3>
        <ol>
            <li>基本数据类型：变量存放的是变量的值</li>
            <li>引用数据类型：变量存放的是变量值所在地址空间的引用</li>
        </ol>
        <h3>基本数据类型</h3>
        <ul>
            <li>String</li>
            <li>Number</li>
            <li>Boolean</li>
            <li>null</li>
            <li>undefined</li>
        </ul>
        <h3>引用数据类型</h3>
        <ul>
            <li>Object</li>
            <li>Array</li>
            <li>Function</li>
            <li>Date</li>
        </ul>
        <h3>对象的key，数组的key</h3>
        <ol>
            <li><b>对象的Key：</b>key-value对里key的值</li>
            <li>
                <b>数组的Key：</b>
                <span>数组看似没有类似对象的key，其实js为数组的每一项设计了下标，从0开始。而这个下标在内存中，就是数组的key。因此在使用 for...in 循环时，循环出来的是数组的下标。</span>
                <div><img src="./images/arr_obj_keys.jpg" alt=""></div>
            </li>
        </ol>
    </div>
    <script>
        // 解构赋值, 是浅拷贝。只拷贝一层
        let arr = [1, 2, 3]
        let newArr = [...arr]

        // JSON序列化，深拷贝
        let list = [
            { a: 1, b: 'zz' },
            { a: 2, b: 'zy' },
            { a: 3, b: 'zx', c: function() { console.log("I'm fn") } }
        ]
        let listCopy = JSON.parse(JSON.stringify(list))
        console.log('json序列化:', listCopy)

        /**
         * @func deep_clone 深拷贝
         */
        function deepClone(source) {
            // [] => Array(基类)，{} => Object(基类)
            const target = source.constructor === Array ? [] : {}
            // for..in 数组取出下标，对象取出键
            for (let key in source) {
                // 如果是原型链上的属性，无需拷贝
                if (source.hasOwnProperty(key)) {
                    if (source[key] && typeof source[key] === 'object') {
                        // 是对象或数组，递归查找。
                        target[key] = source[key].constructor === Array ? [] : {}  // 维护层代码，起解释性作用
                        target[key] = deepClone(source[key])
                    } else {
                        // 是基本数据类型,或者函数，直接赋值
                        target[key] = source[key]
                    }
                }
            }
            return target
        }

        // 测试 deep clone
        let list2 = deepClone(list)
        list2[1].name = 'second'
        console.log(list, list2)


        function Person() {}
        Person.prototype.class = '1班'
        let student = new Person()
        student.name = 'zfs'
        // 附注：由于for...in遍历查找时，会原型属性也查找出来，深拷贝不需要拷贝此属性，因此要用hasOwnProperty判断下
        for (key in student) {
            console.log(key) // name, class
        }

        let array = ['a', 'c']
        console.log(array)   // 可以看到其实数组也是有“键”的，它的键就是下标
        console.log(array.hasOwnProperty(1)) // true
        console.log(array.hasOwnProperty(3)) // false
    </script>
</body>
</html>