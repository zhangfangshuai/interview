<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>release_subscribe</title>
</head>
<body>
    <h3>发布订阅模式</h3>
    <div style="width: 100%; height: 2px; background: #F5F5F5;"></div>
    <li>什么是发布订阅模式？</li>
    <br>
    <li>什么是观察者模式？</li>
    <br>
    <li>事件监听 target.addEventListener('click', fn, false)</li>
    <script>
        /**
         * @func 事件监听是我们常用的发布-订阅者模式 
         * @desc 第三个参数可以指定如下几个值
         * 1）capture:true, 在事件捕获阶段触发；
         * 2）once:true, 只触发一次；
         * 3）false/true - 沿着dom树冒泡上来的时间是否需要触发本监听
         * 4）其他不常用
         */
        target.addEventListener('click', function() {
            console.log('user click here')
        }, false)




        /**
         * @func 观察者模式：观察者观察发布者是否发布消息，发布了消息，执行事件
         * @desc 定义： 发布者，观察者
         * @desc 使用： 1）发布者添加观察者，2）发布消息，3）观察者执行事件
         */

        // 发布者
        class Releaser {
            constructor() {
                this.watcherHub = {}
            }

            // 添加观察者
            addWatcher(key, watcher) {
                if (!key) return
                if (watcher && watcher.update) {
                    (this.watcherHub[key] || (this.watcherHub[key] = [])).push(watcher)
                }
            }

            // 发布通知
            notify(key, msg) {
                [].forEach.call(this.watcherHub[key], function(watcher) {
                    watcher.update.call(this, msg)
                })
            }
        }

        // 观察者
        class Watcher {
            constructor() {}
            update(msg) {
                console.log('观察者观察消息：', msg)
            }
        }

        /* ------------ 使用 ------------- */
        // 1）初始化
        let w1 = new Watcher()
        let r1 = new Releaser()
        // 2）添加观察者
        r1.addWatcher('warning', w1)
        // 3）发布消息
        r1.notify('warning', '我捡到了100w')




        /* -------- 实现发布订阅者模式的四种思路 ---------- */

        /**
         * @func 单页面单发布者模型 - 基础实现
         */

        let releaser = {};  // 发布者
        releaser.events = {}; // 发布者事件存储器，不同事件区分key存储。这里不要用数组存储，否则赋值时key被当做下标，做深拷贝。二对象不会

        /**
         * @func 订阅函数的添加方法
         * @param key 事件类别,识别码
         * @param fn 事件
         */
        releaser.listen = function(key, fn) {
            if (!this.events[key]) {
                this.events[key] = []
            }
            this.events[key].push(fn)
        }

        /**
         * @func 发布者的发布方法：当发布者发布函数，触发订阅函数执行
         * @param {Object} arguments: {key, fn}
         */
        releaser.trigger = function() {
            const [ key, ...args ] = arguments || {} // es6
            // call-方法执行时使用指定数据对象环境进行执行
            // let key = Array.prototype.shift.call(arguments) // Es5-注意shift改变了原数组
            let events = this.events[key]

            if (!events || events.length === 0) return

            for ( let fn of events ) {
                fn.apply(this, args); // apply-方法执行时，将this指向指定环境中
            }
        }

        // 订阅者A订阅事件eType1，当发布者发布此事件时，执行订阅事件
        releaser.listen('eType1', function(eName) {
            console.log('订阅者A订阅了类型1的事件:', eName)
        })

        // 订阅者B订阅事件eType2
        releaser.listen('eType2', function(eName) {
            console.log('订阅者B订阅了类型2的事件:', eName)
        })

        // 发布者发布消息
        releaser.trigger('eType1', '发布者发布了类型1的消息')
        releaser.trigger('eType2', '发布者发布了类型2的消息')



        /**
         * @func 创造模板，利用拷贝生成实例。将函数和方法抽象到对象属性 - 利用对象载体
         */
        let RelSubModule = {
            // 事件池
            events: {},
            // 添加订阅者
            listen: function(key, fn) {
                (this.events[key] || (this.events[key] = [])).push(fn)
            },
            // 发布者发布消息函数
            trigger: function() {
                // const [key, ...args] = arguments // Es6
                let key = Array.prototype.shift.call(arguments), // es5
                    fns = this.events[key]
                if (!fns || fns.length === 0) return

                for (let fn of fns) {
                    fn.apply(this, arguments)
                }
            },
            // 移除某条消息
            remove(key, fn) {
                let fns = this.events[key]
                if (!fns || fns.length === 0) return
                // 如果没传指定事件，只传了事件类型，则移除整个事件类型下的所有事件
                if (!fn) {
                    this.events[key] === []
                } else {
                    // 数组删除
                    for (let i = fns.length - 1; i >= 0; i--) {
                        let _fn = fns[i]
                        _fn === fn && (this.events[key].splice(i, 1))
                        break
                    }
                }
            }
        }

        // 使用
        let eventObj = {}
        Object.keys(RelSubModule).forEach(key => eventObj[key] = RelSubModule[key])

        // 添加订阅
        eventObj.listen('e1', function(releaseMsg) {
            console.log('事件类型e1订阅了消息: ', releaseMsg)
        })

        eventObj.trigger('e1', '发布事件e1')




        /**
         * @func 发布-订阅模式
         * @desc 理解：如微信订阅号： 发布者发布消息，通过微信订阅平台，将消息推送给订阅者；又如淘宝平台，商家在淘宝上新货，淘宝推送商品给顾客
         * @desc 成员：发布者、订阅者、事件中心(中介)
         * @desc 使用：发布者发布消息，事件中心存储消息，事件中心推送消息，订阅者执行订阅事件
         */
        let ReleaseSubscribeModule = function() {
            // 事件中心
            this.eventHub = {}
        }

        ReleaseSubscribeModule.prototype = {
            // 添加订阅者
            subscribe(key, fn) {
                if (!key) {
                    alert('订阅失败！必须传入事件类别')
                    return
                }
                (this.eventHub[key] || (this.eventHub[key] = [])).push(fn)
            },
            // 发布者
            release() {
                let key = Array.prototype.shift.call(arguments),
                    fns = this.eventHub[key]
                    
                if (!fns || fns.length === 0) return
                fns.forEach(fn => {
                    fn.apply(this, arguments)
                })
            },
            // 取消订阅
            remove(key, fn) {
                let fns = this.eventHub[key]
                if (!fns || fns.length === 0) return
                if (!fn) {
                    this.eventHub[key] = []
                } else {
                    for (let i = fns.length -1; i >= 0 ; i--) {
                        let _fn = fns[i]
                        (_fn === fn) && (this.eventHub[key].splice(i, 1))
                    }
                }
            }
        }

        // 使用
        let sample = new ReleaseSubscribeModule()

        sample.subscribe('e1', function(msg) {
            console.log('订阅者订阅了E1: ', msg)
        })

        sample.release('e1', '发布者发布了e1类型事件')











        






        /**
         * @func 高内聚，低耦合模型 - 使用闭包
         * @desc 将发布者全局化，解耦订阅者与发布者互相感知的关系,并且，订阅者并不关心订阅事件有多少
         * @desc 将发布函数、订阅函数的添加方法聚合在发布者内部，订阅者不需要关心整个事件订阅过程，只需要使用全局发布者的方法即可
         * @param {Object} events 事件存储容器
         * @param {Function} listen 添加订阅函数的方法
         * @param {Function} trigger 发布者触发订阅函数执行的方法
         * @param {Function} remove 移除某个订阅函数的方法
         */
        let Event = (function() {
            // events 不用数组存储，原因是数组存储key时会被当做下标处理，在trigger赋值时会做深拷贝，浪费性能
            let events = {}, listen, trigger, remove;

            listen = function (key, fn) {
                (events[key] || (events[key] = [])).push(fn)
            };

            trigger = function() {
                let [key, ...args] = arguments, fns = events[key];
                // let key = Array.prototype.shift.call(arguments)  // Es5-下方改成fn.apply(this, arguments)
                if (!fns || fns.length === 0) return

                for (let fn of fns) {
                    fn.apply(this, args)
                }
            };

            // 只传key表示清楚key下所有事件，传了key和fn，表示清除key下的fn事件
            remove = function(key, fn) {
                let fns = events[key]
                if (!fns) return
                if (!fn) {
                    fns.length = 0
                } else {
                    // 从后往前遍历删除
                    for (let i = fns.length - 1; i >= 0; i--) {
                        let _fn = fns[i]
                        _fn === fn && (fn.splice(i, 1))
                    }
                }
            };

            // 使用闭包导出，数据(如list)都是内部的，不受外部干扰很安全
            return {
                listen,
                trigger,
                remove
            }
        })();


        // 使用
        // 订阅者订阅事件
        Event.listen('event1', function(event) {
            console.log('订阅者订阅事件event1: ', event)
        })

        // 发布者发布事件，传达给订阅者
        Event.trigger('event1', '发布者发布event1事件了')
    </script>
</body>
</html>