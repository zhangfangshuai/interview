<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>study_v-model</title>
    <script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js"></script>
</head>
<body>
    <h3>v-model 官方案例</h3>
    <div id="app">
        <input v-model="name" placeholder="请输入-vue官方案例" />
        <div>vue案例显示值: {{ name }}</div>
    </div>
    <script>
        new Vue({
            el: '#app',
            data () {
                return {
                    name: ''
                }
            }
        })
    </script>



    <h3>v-model 手写案例</h3>
    <input id="username" placeholder="请输入" />
    <div>双向绑定显示值：<span id="uName"></span></div>

    <script>
        /**
         * @func Object.defineProperty()方法理解
         * @desc 用户给对象定一个新属性，或修改一个现有属性的值或其他描述，并返回此对象
         */
        const object1 = {}
        Object.defineProperty(object1, 'property1', {
            configurable: false, // 对象属性能否被删除，其他描述符是否可被改变 - 默认false
            enumerable: true, // 是否可被枚举出来, 如 for...in, Object.keys()等 - 默认false。
            writable: false, // 不可写入 - 默认false
            value: 42, // 值 - 默认undefined
            // 属性的getter方法，当该属性被读取时，调用此函数 - 默认undefined
            get() { 
                return this.value
            },
            // 属性的setter方法，当属性值被设置或修改时，调用此函数 - 默认undefined
            set(newVal) {
                this.value = newVal
                console.log(newVal, this)
            }
        })
        object1.value = 77
        console.log(object1.value) // 42
        delete object1.property1 // 不执行任何逻辑，因为configurable未false
        
        // 普通的执行赋值，等同于描述符都为true
        object1.b = 2
        // 等同于
        Object.defineProperty(object1, 'b', {
            configurable: true,
            enumerable: true,
            writable: true,
            value: 2
        })

        // 继承属性，原型属性 prototype 上的属性是会被继承的
        Object.defineProperty(Object1.prototype, 'x', {})




        /**
         * @func 使用Object.defineProperty 实现双向数据绑定的简单案例
         * 1、监听input的keyup事件的发生
         * 2、keyup发生，导致input内容改变，修改obj的属性的值
         * 3、通过defineProperty劫持你对对象obj的操作，属性值的改变
         * 4、通过set方法，设置或更新绑定位置位置的显示内容
         */
        let person = {}
        Object.defineProperty(person, "username", {
            get: function() {
                console.log('取值')
            },
            set: function(val) {
                console.log('设置值')
                document.getElementById('uName').innerText = val
            }
        })
        // 监听input的keyup事件，触发obj.username属性发生改变，从而触发defineProperty监听
        document.getElementById('username').addEventListener('keyup', function() {
            // 监听事件有内置对象 event
            person.username = event.target.value
        })




        /**
         * @func vue实现双向数据绑定核心原理 
         * @desc vue2.x
         */
        let data = { msg: 'vue2', count: 10 },
            vm = {}
        proxyData()
        // 双线个数据绑定实现原理
        function proxyData(data) {
            Object.keys(data).forEach(key => {
                Object.defineProperty(vm, key, {
                    configurable: true,
                    enumerable: true,
                    writable: true,
                    get() {
                        return data[key]
                    },
                    set(newVal) {
                        data[key] = newVal
                        document.querySelector('#app').textContent = data[key]
                    }
                })
            })
        }
        vm.msg   // vue2, 访问次属性，调用getter方法，打印data.msg
        vm.msg = 'hello vue3'  // 设置新属性，调用setter方法，并渲染到页面上
        vm.msg   // hello vue3




        /**
         * @func vue实现双向数据绑定原理
         * @desc vue3.x
         * @desc 与vue2区别：直接监听对象,而非属性,ES6中新增,IE不支持,性能由浏览器优化比defineProperty要好, 对于多个属性的值不需要进行循环遍历处理
         */
        let obj = { msg: 'vue3', count: 0 }
        let vm = new Proxy(obj, { // 执行代理行为的函数
            get(target, key) {
                return target[key]
            },
            set(target, key, value) {
                if (target[key] === newValue) return
                target[key] = newValue
                document.querySelector('#app').textContent = target[key]
            }
        })

    </script>
</body>
</html>